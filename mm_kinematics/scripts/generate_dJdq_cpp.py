#!/usr/bin/env python2
import sys
import re
import numpy as np
from mm_kinematics.symbolic import KinematicModel
from mm_kinematics import codegen


TEXT_BEFORE = """
// Autogenerated by generate_dJdq_cpp.py -- do not edit by hand.
#include <ros/ros.h>
#include <Eigen/Eigen>

#include "mm_kinematics/kinematics.h"

namespace mm {
""".lstrip()


TEXT_AFTER = """
} // namespace mm
"""

FUNCTION_VARS = """
    // Base joints
    double xb = q(0);
    double yb = q(1);
    double stb = std::sin(q(2));
    double ctb = std::cos(q(2));

    // Arm joints
    double sq1 = std::sin(q(3));
    double cq1 = std::cos(q(3));
    double sq2 = std::sin(q(4));
    double cq2 = std::cos(q(4));
    double sq3 = std::sin(q(5));
    double cq3 = std::cos(q(5));
    double sq4 = std::sin(q(6));
    double cq4 = std::cos(q(6));
    double sq5 = std::sin(q(7));
    double cq5 = std::cos(q(7));
    double sq6 = std::sin(q(8));
    double cq6 = std::cos(q(8));
"""

JOINT_NAMES = ['xb', 'yb', 'tb', 'q1', 'q2', 'q3', 'q4', 'q5', 'q6']


def vector_joint_names(s):
    """Convert from symbolic names to Eigen vector format."""
    for i, qi in enumerate(JOINT_NAMES):
        s = re.sub(qi, 'q({})'.format(i), s)
    return s


def encode_matrix(J):
    """Encode matrix as a string."""
    J_str = np.empty(J.shape, dtype=object)
    for i in range(J.shape[0]):
        for j in range(J.shape[1]):
            s = str(J[i, j])
            s = vector_joint_names(s)
            J_str[i, j] = s
    return J_str


def dJa_dqi_function_signature(qi):
    """Function signature for the derivative of dJa w.r.t. joint qi."""
    return "void Kinematics::calc_dJa_d" + qi + "(const JointVector& q, ArmJacobianMatrix& dJa)"


def dJa_dqi_function_code(dJa_dqi, qi):
    """Complete function code derivative of arm Jacobian w.r.t. joint dq."""
    dJa_dqi_str = codegen.encode_matrix(dJa_dqi)
    items = [dJa_dqi_function_signature(qi) + ' {', FUNCTION_VARS]

    msg = "  {}({},{}) = {};"
    for i in range(6):
        for j in range(6):
            items.append(msg.format('dJa', i, j, dJa_dqi_str[i, j]))
    items.append('}\n')

    return '\n'.join(items)


def main():
    if len(sys.argv) < 2:
        print('Usage: generate_dJdq_cpp.py path')
        return

    path = sys.argv[1]
    model = KinematicModel()

    # generate the symbolic derivatives
    Ja = model.J[:, 3:]
    dJa_dqs = [Ja.diff(qi) for qi in model.q]

    # generate the C++ code for each derivative
    items = [TEXT_BEFORE]
    for qi, dJa_dqi in zip(JOINT_NAMES, dJa_dqs):
        code = dJa_dqi_function_code(dJa_dqi, qi)
        items.append(code)
    items.append(TEXT_AFTER)

    with open(path, 'w+') as f:
        f.write('\n'.join(items))



if __name__ == '__main__':
    main()
