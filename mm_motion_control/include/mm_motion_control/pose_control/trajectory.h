#pragma once

#include <Eigen/Eigen>
#include <ros/ros.h>
#include <tf/transform_datatypes.h>
#include <geometry_msgs/Pose.h>

#include <mm_kinematics/kinematics.h>
#include <mm_msgs/PoseTrajectoryPoint.h>
#include <mm_msgs/PoseTrajectory.h>
#include <mm_msgs/conversions.h>
#include <mm_math_util/interp.h>


namespace mm {


class PoseTrajectory {
    public:
        PoseTrajectory();

        // Follow a trajectory of waypoints.
        bool follow(mm_msgs::PoseTrajectory trajectory);

        // Offset the position of a trajectory by p.
        void offset(const Eigen::Vector3d& p);

        // If we're staying at a point, it is assumed the desired velocity is
        // zero.
        bool stay_at(const Eigen::Vector3d& p, const Eigen::Quaterniond& q);

        // Sample the trajectory at time t.
        bool sample(const double t, Eigen::Vector3d& p, Eigen::Vector3d& v,
                    Eigen::Quaterniond& q, Eigen::Vector3d& w);

        // Overloaded version in terms of poses and twists.
        bool sample(const double t, Eigen::Affine3d& pose, Vector6d& twist);

        // Returns true if trajectory is finished, false otherwise.
        bool done(double t);

    private:
        double t0; // start time
        double tf; // end time
        double dt; // time step

        // List of waypoints defining the entire trajectory.
        std::vector<mm_msgs::PoseTrajectoryPoint> waypoints;

        // Cubic interpolation for the linear component.
        // CubicInterp<3> lerp;
        QuinticInterp<3> lerp;

        // Spherical linear interpolation (slerp) for the angular component.
        QuaternionInterp slerp;

        // Assume angular velocity is constant throughout the
        // trajectory. Indeed, if it is not, then we should be doing
        // something more complicated than slerp.
        Eigen::Vector3d w_prev;

        // Position offset. In our case, generated by force control.
        Eigen::Vector3d p_off;

        bool stationary;
        Eigen::Vector3d stationary_position;
        Eigen::Quaterniond stationary_rotation;

        /* FUNCTIONS */

        bool interpolate(const double t, Eigen::Vector3d& p, Eigen::Vector3d& v,
                         Eigen::Quaterniond& q, Eigen::Vector3d& w);

}; // class PoseTrajectory


} // namespace mm
