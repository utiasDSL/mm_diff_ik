#pragma once

#include <Eigen/Eigen>
#include <ros/ros.h>
#include <realtime_tools/realtime_publisher.h>

#include <geometry_msgs/PoseStamped.h>
#include <sensor_msgs/JointState.h>
#include <geometry_msgs/Vector3Stamped.h>
#include <std_msgs/Float64.h>

#include <mm_msgs/PoseTrajectory.h>
#include <mm_msgs/PoseControlState.h>
#include <mm_msgs/Obstacles.h>
#include <mm_msgs/ForceInfo.h>
#include <mm_kinematics/kinematics.h>

#include "mm_motion_control/pose_control/optimizer.h"
#include "mm_motion_control/pose_control/trajectory.h"
#include "mm_motion_control/pose_control/obstacle.h"
#include "mm_motion_control/pose_control/controller.h"


namespace mm {


// The IKControllerManager runs the control loop that commands and receives feedback
// from the robot.
class IKControllerManager {
    public:
        IKControllerManager() : controller() {}

        bool init(ros::NodeHandle& nh);

        // Enter control loop.
        // Parameters:
        //   hz: rate at which to run the loop
        void loop(const double hz);

    private:
        // Pattern followed by ROS control for typedefing.
        typedef realtime_tools::RealtimePublisher<mm_msgs::PoseControlState> StatePublisher;
        typedef std::unique_ptr<StatePublisher> StatePublisherPtr;

        /** VARIABLES **/

        StatePublisherPtr state_pub;

        // Subsribe to desired end effector pose trajectories.
        ros::Subscriber pose_traj_sub;

        ros::Subscriber point_traj_sub;

        // Subscribe to current joint values of the robot.
        ros::Subscriber mm_joint_states_sub;

        // Subscribe to position offset generated by force control.
        ros::Subscriber force_position_offset_sub;

        ros::Subscriber force_info_sub;
        ros::Subscriber force_des_sub;

        // Subscribe to obstacle detections.
        ros::Subscriber obstacle_sub;

        // Publishers for desired joint speeds calculated by controller.
        ros::Publisher ur10_joint_vel_pub;
        ros::Publisher rb_joint_vel_pub;

        IKController controller;

        // Actual joint positions and velocities, updated by the subscriber
        JointVector q;
        JointVector dq;

        // Trajectory interpolator.
        PoseTrajectory trajectory;

        double fd; // Desired force.
        Eigen::Vector3d force;  // Applied end effector force.
        bool first_contact;  // True if contact has been made.
        Eigen::Vector3d pc;  // First contact point.

        std::vector<ObstacleModel> obstacles;

        // True if we currently have a trajectory to follow, false otherwise.
        bool traj_active;


        /** FUNCTIONS **/

        // Receive a trajectory of waypoints to follow.
        void pose_traj_cb(const mm_msgs::PoseTrajectory& msg);

        // Receive a command to keep the EE in place (but the motion control
        // loop is still running so it can respond to e.g. applied forces).
        void point_traj_cb(const geometry_msgs::PoseStamped& msg);

        // Update state of robot joints.
        void mm_joint_states_cb(const sensor_msgs::JointState& msg);

        // Receive position offset generated by force control.
        void pos_offset_cb(const geometry_msgs::Vector3Stamped& msg);

        // Receive list of obstacles for the base to avoid.
        void obstacle_cb(const mm_msgs::Obstacles& msg);

        // Receive information about force measurements.
        void force_info_cb(const mm_msgs::ForceInfo& msg);

        // Receive new value for desired force.
        void force_des_cb(const std_msgs::Float64 msg);

        // Publish joint speeds computed by the controller to the arm and base.
        void publish_joint_speeds(const JointVector& dq_cmd);

        // Publish the current control state of the robot: actual and desired
        // poses, and pose error.
        void publish_robot_state(const Eigen::Affine3d& Td,
                                 const JointVector& u);
}; // class IKControllerManager

} // namespace mm
