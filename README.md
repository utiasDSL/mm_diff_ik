# Mobile Manipulation

High-performance optimization-based control for mobile manipulation.

This repository contains ROS packages for control of the UTIAS mobile
manipulator. It is designed to be install on Ubuntu 14.04 with ROS Indigo,
because these are the versions in use on the robot itself (as of May 2020).

If you have a later version of Ubuntu, you can emulate a 14.04 environment
using [docker](https://github.com/adamheins/mm-docker).

## Installation

First, install required dependencies we can get from `apt`:
```
sudo apt install ros-indigo-soem ros-indigo-ur-modern-driver libeigen3-dev
```
Symlink to Eigen:
```
sudo ln -s /usr/include/eigen3/Eigen /usr/include/Eigen
```

Next, clone [vicon_bridge](https://github.com/ethz-asl/vicon_bridge) and
[robotiq](https://github.com/ros-industrial/robotiq) into the `src` directory
of your catkin workspace. 

Finally, you'll also need to install [qpOASES](https://github.com/coin-or/qpOASES).
Clone the repository somewhere convenient (not your catkin workspace; it's not
a ROS package). Then, to compile, simply enter the cloned repo and type `make`.
To get ROS to find the qpOASES headers, you'll need to make some symlinks:
```
sudo ln -s <path/to/qpOASES>/include/qpOASES.hpp /usr/local/include/qpOASES.hpp
sudo ln -s <path/to/qpOASES>/include/qpOASES     /usr/local/include/qpOASES
sudo ln -s <path/to/qpOASES>/bin/libqpOASES.so   /usr/local/lib/libqpOASES.so
```

Now, clone this repository into the `src` directory of your catkin workspace.
Then you should be able to build with `catkin` (alternatively use `catkin_make`
or `catkin_make_isolated`):
```bash
# normal build
catkin build

# with compiler optimizations
catkin build -DCMAKE_BUILD_TYPE=Release
```

## Packages

### mm_motion_control

Inner-loop motion controller that implements proportional control with velocity
feedforward in task space, followed by an optimization over the joint
velocities to send to the robot. Written in C++. Optimizer is qpOASES.

#### Subscribers
* `/trajectory/point` (`geometry_msgs/PoseStamped`): Takes a single pose in
  task space to control toward at a specified future time.
* `/trajectory/poses` (`mm_msgs/PoseTrajectory`): Takes a trajectory of poses
  in task space to track.
* `/mm_joint_states` (`sensor_msgs/JointState`): Takes position and velocity
  of the joints of the Thing.
  (`ur_modern_driver`).
* `/obstacles` (`mm_msgs/Obstacles`): Contains all detected obstacles.
* `/force_control/position_offset` (`geometry_msgs/Vector3Stamped`): Position
  offset generated by force controller.

#### Publishers
* `/ur_driver/joint_speed` (`trajectory_msgs/JointTrajectory`): Publishes joint
  speed commands to the UR10. Only the first point is parsed, and then only the
  velocities (and possibly accelerations---not sure about this)
* `/ridgeback_velocity_controller/cmd_vel` (`geometry_msgs/Twist`): Publishes
  joint speed commands to the Ridgeback base.
* `/mm_pose_state` (`mm_msgs/PoseControlState`): Information about the actual,
  desired, and error pose of the EE.

### mm_force_control

Outer-loop force controller, also responsible for trajectory generation. Runs
at ~10Hz. Written in Python.

### mm_simulation

Basic simulation of the Thing kinematics in Python for visualization. Should
eventually be replaced by a proper Gazebo simulation.

### mm_msgs

Defines custom ROS messages used by other packages in the project.

### mm_vicon

Contains Vicon estimation code and launch files for the Vicon system. To
publish the Thing base pose from Vicon, connect to the Vicon wifi
`DSL_DroneNet_5G` (see the wiki for the password) and run `roslaunch mm_vicon
vicon.launch`. You should see the topic `/vicon/ThingBase/ThingBase` bring
published.

### mm_kinematics

Contains forward kinematics code in both C++ and Python for use by other
packages.

## Run
### Simulation
```bash
> roscore
> roslaunch mm_simulation sim.launch
> rosrun mm_motion_control mm_control_node
> rosrun mm_trajectories [trajectory].py
```
where `[trajectory]` is replaced the desired trajectory.

### Experiment
1. Connect to `DSL_DroneNet_5G` network.
2. Connect to the Thing via Ethernet.
3. Ensure ROS is configured to use the Thing as master:
   ```bash
   laptop > export ROS_IP=192.168.131.100
   laptop > export ROS_MASTER_URI=http://cpr-tor11-01:11311
   ```
   If you run `rostopic list`, you should see various topics related to the Thing
   listed.
4. Run:
   ```bash
   # on laptop
   laptop > roslaunch mm_vicon vicon.launch

   # alternatively, if Vicon is not available
   laptop > roslaunch mm_vicon spoof.launch

   # start the UR10 driver (the Ridgeback starts automatically onboard the
   # robot) and the mux node that publishes the combined /mm_joint_states
   # topic.
   laptop > roslaunch mm_motion_control bringup.launch

   # start the motion control node
   laptop > rosrun mm_motion_control mm_control_node

   # if using force control
   robot > roslaunch mm_force_control force.launch
   laptop > rosrun mm_force_control force.py

   # example of running a trajectory
   # inspect the file first to ensure the trajectory does what you expect
   laptop > rosrun mm_trajectories line.py
   ```

### Go Home
Go to home position defined in the launch file. Requires bringup.launch to
already be launched and running.
```bash
laptop > roslaunch mm_motion_control home.launch
```

### Gripper
Open or close the gripper (experiment only). Run on the laptop:
```bash
laptop > roslaunch mm_gripper gripper.launch

# <cmd> is either o (open) or c (close)
laptop > rosrun mm_gripper gripper.py <cmd>
```

