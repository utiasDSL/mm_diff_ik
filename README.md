# Mobile Manipulation

High-performance optimization-based control for mobile manipulation.

This repository contains ROS packages for control of the UTIAS mobile
manipulator (the "Thing"). It is designed to be installed on Ubuntu 14.04 with
ROS Indigo, because these are the versions in use on the robot itself (as of
January 2021).

If you have a later version of Ubuntu, you can emulate a 14.04 environment
using [docker](https://github.com/adamheins/mm-docker).

## Robot Information

### Hardware

The robot consists of a UR10 manipulator mounted on a Ridgeback omnidirectional
mobile base. The base has a Hokuyo UST-10LX laser range finder mounted at the
front that provides a two-dimensional scan in a 270 degree arc in front of the
robot. The end effector has a Robotiq FT 300 force torque sensor mounted at the
wrist to measure the applied wrench, as well as Robotiq 3 finger gripper for
manipulation. See the `datasheets/` directory for more details on each of the
components.

### Software

The UR10 is running firmware version 3.9 and communicating using
[ur_modern_driver](https://github.com/ros-industrial/ur_modern_driver), which
is deprecated. A complete upgrade of the system and dependencies to a more
recent version of Ubuntu, ROS, driver, and firmware is planned for sometime in
the future.

## Software Installation

First, install required dependencies we can get from `apt`:
```
sudo apt install ros-indigo-soem ros-indigo-ur-modern-driver libeigen3-dev
```
Symlink to Eigen:
```
sudo ln -s /usr/include/eigen3/Eigen /usr/include/Eigen
```

Next, clone [vicon_bridge](https://github.com/ethz-asl/vicon_bridge) and
[robotiq](https://github.com/ros-industrial/robotiq) into the `src` directory
of your catkin workspace. 

Finally, you'll also need to install [qpOASES](https://github.com/coin-or/qpOASES).
Clone the repository somewhere convenient (not your catkin workspace; it's not
a ROS package). Then, to compile, simply enter the cloned repo and type `make`.
To get ROS to find the qpOASES headers, you'll need to make some symlinks:
```
sudo ln -s <path/to/qpOASES>/include/qpOASES.hpp /usr/local/include/qpOASES.hpp
sudo ln -s <path/to/qpOASES>/include/qpOASES     /usr/local/include/qpOASES
sudo ln -s <path/to/qpOASES>/bin/libqpOASES.so   /usr/local/lib/libqpOASES.so
```

Now, clone this repository into the `src` directory of your catkin workspace.
Then you should be able to build with `catkin` (alternatively use `catkin_make`
or `catkin_make_isolated`):
```bash
# normal build
catkin build

# with compiler optimizations (this makes it run much faster)
catkin build -DCMAKE_BUILD_TYPE=Release
```

## Packages

### mm_motion_control

Inner-loop motion controller that implements proportional control with velocity
feedforward in task space, followed by an optimization over the joint
velocities to send to the robot. Written in C++. Optimizer is qpOASES.

#### Subscribers
* `/trajectory/point` (`geometry_msgs/PoseStamped`): Takes a single pose in
  task space to control toward at a specified future time.
* `/trajectory/poses` (`mm_msgs/PoseTrajectory`): Takes a trajectory of poses
  in task space to track.
* `/mm_joint_states` (`sensor_msgs/JointState`): Takes position and velocity
  of the joints of the Thing.
  (`ur_modern_driver`).
* `/obstacles` (`mm_msgs/Obstacles`): Contains all detected obstacles.
* `/force_control/position_offset` (`geometry_msgs/Vector3Stamped`): Position
  offset generated by force controller.

#### Publishers
* `/ur_driver/joint_speed` (`trajectory_msgs/JointTrajectory`): Publishes joint
  speed commands to the UR10. Only the first point is parsed, and then only the
  velocities (and possibly accelerations---not sure about this)
* `/ridgeback_velocity_controller/cmd_vel` (`geometry_msgs/Twist`): Publishes
  joint speed commands to the Ridgeback base.
* `/mm_pose_state` (`mm_msgs/PoseControlState`): Information about the actual,
  desired, and error pose of the EE.

### mm_force_control

Outer-loop force controller, also responsible for trajectory generation. Runs
at ~10Hz. Written in Python.

### mm_simulation

Basic simulation of the Thing kinematics in Python for visualization. Should
eventually be replaced by a proper Gazebo simulation.

### mm_msgs

Defines custom ROS messages used by other packages in the project.

### mm_vicon

Contains Vicon estimation code and launch files for the Vicon system. To
publish the Thing base pose from Vicon, connect to the Vicon wifi
`DSL_DroneNet_5G` (see the wiki for the password) and run `roslaunch mm_vicon
vicon.launch`. You should see the topic `/vicon/ThingBase/ThingBase` bring
published.

### mm_kinematics

Contains forward kinematics code in both C++ and Python for use by other
packages.

## Simulation

This repository contains a very basic simulation of the robot in
`mm_simulation`, which is just a wireframe in a 3D matplotlib plot. To use
this, run:
```bash
> roscore
> roslaunch mm_simulation sim.launch
> rosrun mm_motion_control mm_control_node
> rosrun mm_trajectories [trajectory].py
```
where `[trajectory]` is replaced the desired trajectory.

Alternatively, there is a separate
[respository](https://github.com/utiasDSL/dsl__projects__mobile_manipulator_gazebo)
containing packages for a Gazebo simulation, which should be entirely
compatible with the controllers in this package. Assuming that repository has been installed in the workspace, built, and sourced, then instead of
```
> roslaunch mm_simulation sim.launch
```
one can use
```
> roslaunch mm_gazebo simulation.launch
```
Everything else should remain the same.

## Experiment
Steps for experiments on the real robot:

1. Connect to `DSL_DroneNet_5G` network.
2. Connect to the Thing via Ethernet.
3. Ensure ROS is configured to use the Thing as master:
   ```bash
   laptop > export ROS_IP=192.168.131.100
   laptop > export ROS_MASTER_URI=http://cpr-tor11-01:11311
   ```
   If you run `rostopic list`, you should see various topics related to the Thing
   listed.
4. Run:
   ```bash
   # on laptop
   laptop > roslaunch mm_vicon vicon.launch

   # alternatively, if Vicon is not available
   laptop > roslaunch mm_vicon spoof.launch

   # start the UR10 driver (the Ridgeback starts automatically onboard the
   # robot) and the mux node that publishes the combined /mm_joint_states
   # topic.
   # NOTE: this does usually run fine on the laptop, but can occasionally
   # generate garbage values for joint position or velocity. On the other hand,
   # running on the Thing may have time sync issues between the two computers.
   laptop > roslaunch mm_motion_control bringup.launch

   # start the motion control node
   laptop > rosrun mm_motion_control mm_control_node

   # if using force control
   robot > roslaunch mm_force_control force.launch
   laptop > rosrun mm_force_control force.py

   # example of running a trajectory
   # inspect the file first to ensure the trajectory does what you expect
   laptop > rosrun mm_trajectories line.py
   ```

### Go Home
Go to home position defined in the launch file. Requires bringup.launch to
already be launched and running.
```bash
laptop > roslaunch mm_motion_control home.launch
```

### Gripper
Open or close the gripper (experiment only). Run on the laptop:
```bash
laptop > roslaunch mm_gripper gripper.launch

# <cmd> is either o (open) or c (close)
laptop > rosrun mm_gripper gripper.py <cmd>
```

### Set desired force
To set the desired force at runtime, use:
```
laptop > rostopic pub /force/desired std_msgs/Float64 <value>
```
